/*Объекты «промисы»
Промис — это объект, который используется для упорядочивания синхронных и асинхронных операций. При использовании промисов код становится чище, поэтому они всё чаще встречаются в проектах.
*/
const fetchingPosts = new Promise((res, rej) => {
  $.get("/posts")
    .done(posts => res(posts))
    .fail(err => rej(err));
});

fetchingPosts
  .then(posts => console.log(posts))
  .catch(err => console.log(err));
/*
AJAX-запрос при выполнении не является синхронным, поскольку ответ от ресурса идёт какое-то время. Он может вообще не прийти, если ресурс не доступен (404). Для решения этой проблемы в ES2015 добавили промисы, которые принимают 3 состояния:

ожидание;
выполнен;
отклонён.
Представим, что нам нужно создать Ajax-запрос до ресурса X. Используем для этого метод jQuery.get():
*/
const xFetcherPromise = new Promise( // создаём промис, используя ключевое слово new и записываем его в переменную
  function(resolve, reject) { // конструктор промиса использует аргумент функции с другими аргументами — resolve и reject
    $.get("X") // посылаем AJAX-запрос
      .done(function(X) { // как только запрос завершён
        resolve(X); // промис использует resolve с переменной X в качестве аргумента
      })
      .fail(function(error) { // если запрос отклонён
        reject(error); // промис использует reject с error в качестве аргумента
      });
  }
)
/*
Объект Promise выполняет функцию executor с аргументами resolve и reject. Эти аргументы выполняются по завершении операции как и функции, которые переводят промис из состояния ожидания в состояние выполнения или отклонения. Функция executor выполняется сразу после создания промиса в статусе ожидания. Как только аргументами функции становятся resolve или reject, промис использует необходимые методы.

Используем методы промиса, чтобы получить его выполнение или ошибку:
*/
xFetcherPromise
  .then(function(X) {
    console.log(X);
  })
  .catch(function(err) {
    console.log(err)
  })
/*
В случае сдержанного промиса выполняется resolve и функция с методом .then. Иначе выполняется reject и функция с методом .catch. Также обработчик будет выполнен при сдержанном или нарушенном промисе, что приведёт к отсутствию «состояния гонки» между завершением асинхронной операции и применением обработчика.*/