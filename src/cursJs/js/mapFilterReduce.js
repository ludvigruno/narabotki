/*Методы массивов map/filter/reduce
Методы массивов пришли в JavaScript из функционального программирования. Используя три этих метода, вы избегаете циклов for и forEach в большинстве ситуаций. Попробуйте вместо for использовать совокупность map, filter и reduce. В первый раз будет сложно, потому что придётся научиться мыслить иначе, но дальше привыкнете. Посчитаем для примера сумму оценок студентов с результатом 10 и выше, используя три этих метода:
*/
const students = [
  { name: "Nick", grade: 10 },
  { name: "John", grade: 15 },
  { name: "Julia", grade: 19 },
  { name: "Nathalie", grade: 9 },
];

const aboveTenSum = students
  .map(student => student.grade) // сравниваем массив студентов с массивом их оценок
  .filter(grade => grade >= 10) // отбираем оценки выше 10
  .reduce((prev, next) => prev + next, 0); // суммируем каждую оценку выше 10

console.log(aboveTenSum) // 44 -- 10 (Nick) + 15 (John) + 19 (Julia), Nathalie игнорируется, поскольку её оценка ниже 10
/*"Для более детального наглядного объяснения возьмём массив:"*/

const numbers = [0, 1, 2, 3, 4, 5, 6];
/*Array.prototype.map().*/
const doubledNumbers = numbers.map(function(n) {
  return n * 2;
});
console.log(doubledNumbers); // [0, 2, 4, 6, 8, 10, 12]
/*
"Что мы тут сделали? .map выполняет итерацию каждого элемента массива numbers и перемещает их в функцию. Цель функции — обработать и вернуть новую переменную, чтобы map мог заменить её."

"Теперь посмотрим на функцию отдельно, чтобы было понятнее:"
*/

const doubleN = function(n) { return n * 2; };
const doubledNumbers = numbers.map(doubleN);
console.log(doubledNumbers); // [0, 2, 4, 6, 8, 10, 12]
/*"Метод часто используется со стрелочными функциями:"*/

const doubledNumbers = numbers.map(n => n * 2);
console.log(doubledNumbers); // [0, 2, 4, 6, 8, 10, 12]
/*
Используем numbers.map(doubleN) и получаем
[doubleN(0), doubleN(1), doubleN(2), doubleN(3), doubleN(4), doubleN(5), doubleN(6)]
, что равно [0, 2, 4, 6, 8, 10, 12].
*/
/*
В случае если возвращать массив нет необходимости и нужен цикл с побочными эффектами, используйте for/forEach.
*/
/*Array.prototype.filter().*/
const evenNumbers = numbers.filter(function(n) {
  return n % 2 === 0; // верно, если значение n равно значению, и ложно, если n не равно значению
});
console.log(evenNumbers); // [0, 2, 4, 6]
/*Метод также часто используется со стрелочными функциями:*/

const evenNumbers = numbers.filter(n => n % 2 === 0);
console.log(evenNumbers); // [0, 2, 4, 6]
/*
.filter осуществляет итерацию каждого элемента массива numbers и добавляет их в функцию. Цель функции — вернуть булево значение и определить, нужно оно или нет. После чего фильтр возвращает массив только с добавленными значениями.
*/
/*
Array.prototype.reduce(). Цель метода — сократить переменные до одной после итерации.
*/
const sum = numbers.reduce(
  function(acc, n) {
    return acc + n;
  },
  0 // значение накопительной переменной на первой ступени итерации
);

console.log(sum) // 21
/*Метод также часто используется со стрелочными функциями:*/

const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum) // 21
/*
.reduce применяется к массиву и использует функцию как первый параметр. Однако в данном случае мы сталкиваемся с исключениями:

функция .reduce учитывает 2 параметра: вызываемую на каждом шаге итерации функцию и значение накопительной переменной (acc) на первом шаге итерации.
параметры функции: функция, принятая за значение .reduce, имеет 2 других — накопительную переменную (acc) и текущий элемент (n). Накопительная переменная равна возвращаемому на предыдущем шаге итерации значению функции. На первой ступени acc равна значению, принятому за второй параметр .reduce.
Ступени итерации:

acc = 0, поскольку мы ввели «0» вторым значением для reduce;
n = 0, первый элемент массива number.
Функция возвращает acc + n –> 0 + 0 –> 0
acc = 0, значение, возвращённое функцией на предыдущей ступени итерации;
n = 1, второй элемент массива number.
Функция возвращает acc + n –> 0 + 1 –> 1
acc = 1, значение, возвращённое функцией на предыдущей ступени итерации;
n = 2, третий элемент массива number.
Функция возвращает acc + n –> 1 + 2 –> 3
acc = 3, значение, возвращённое функцией на предыдущей ступени итерации;
n = 3, четвёртый элемент массива number.
Функция возвращает acc + n –> 3 + 3 –> 6
(…действия повторяются до последнего шага)
acc = 15, поскольку это значение функция вернула на предыдущей ступени
n = 6, последний элемент массива number.
На последнем шаге функция возвращает acc + n –> 15 + 6 –> 21
*/