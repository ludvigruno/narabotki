import React from 'react';

/*
хуки это функции обертки
useMemo это хук, React.memo - компонент высшего порядка(HOC-вспомогательная функция)
useMemo - с помощи его можно указать, какую функцию мемоизировать, при каком условии.
useMemo - позволяет выполнять сложную логику только тогда когда это необходимо.
Мемоизация - позволяет схранять результат функции, что бы в последующим не выполнять ее на каждый чих, что то на подобее кэширования.
Получает первым праметром функцию, вторым зависимости, как и useEffect, но разница в том что useMemo возращает результат выполнения функции которую мы передали будет возращен в переменную и при этотм будет следить за зависимостью, если зависимости изменяются то только тогда будет функция выполнятся, если зависимости не меняются, то useMemo будет возращать все тот же результат который был, а если меняется то useMemo опять выполнит функцию, сохранит результат выполения этой функции и каждый раз будет возвращать этот результат.
React.memo = помогает избавится от лишних ререндеров, если мой компонент не меняет состояния то я могу обернуть его в React.memo от лишних ререндеров, для повышения производительности, это значит что React.memo, будет использовать результат предидущего рендера. И будет избегать лишние рендеры.
Разнинца между useMemo и React.memo- не получится исользовать для не компонентов, на пример хранить числа или строчки.
useMemo = помогает решить проблемму слишним вызовым функции..
Но есть еще лучший вариант-
1.проблемма была с функцией сложных вычислений решено - useMemo
2.с лишними ререндарами решено - React.memo
3.проблемма в том что нажимая коунт2 то лишний раз рендерится IsFive притом что IsFive не изменялся так как числа 5 не достиг, мне нужно что бы IsFive не ререндерился когда этого не нужно.Решение - для этого нужно в React.memo вторым параметром написать свою функцию, так как React.memo делает повехностное сравнение пропсов(Shallow Equal)-тоесть идет сравнеие по ссылкам старых пропсов и новых пропсов, если prevProps === newProps то рендера не будет, если prevProps !== newProps то произайдет рендер, праметры зависимости передаеются через анонимную функцию, так как я отказался от стандартного Shallow Equal и прописываю второй параметр, то мой React.memo теперь не знает когда ререндер делать а когда нет и что бы ему сказать надо создать условие в а нонимной функции
С помощи React.memo(я буду делать ререндер только в том случае если твои пропсы изменяются-проверяя их поверхностно, а патом я говорю ему, а давай ты будешь делать рендер только в том случае если value будет 5 и для этого держи проверочную функцию) и useMemo(я буду выполнять твою сложную функцию, когда value изменится, а рендер это вне моей компетенции) - происходит мемоизация.
*/

//счетчик 
const renderCount = 0;
const IsFive = React.memo(function ({value}) {
    console.warn(`IsFive render: ${renderCount+1} `);
    //Эта функция тормозит приложение и поэтому ее надо мемоизировать
    //но она очень нужна
    // const getResult=()=>{
    //     let i=0;
    //     while(i<600000000)i++;
    //     return value ==5?'Это пять :D': 'Это не пять :(';
    // }
    const getResult = React.useMemo(()=>{
          let i=0;
          while(i<600000000)i++;
          return value ==5?'Это пять :D': 'Это не пять :(';
    },[value])
    //getResult = уже не является функцией, а является строчко

    return <h3 style={{margin:"0px 5px auto"}}>{getResult}</h3>
},(prevProps, nextProps)=>nextProps.value === 5?false:true)
//отбражение чисел
const render ={count1:0,count2:0}
const Count =React.memo(function ({id, value}) {
     console.warn(`Count${id} render: ${++render[`count${id}`]}`);
     return <h1>{value}</h1>
})
function App(){
    const [count1, setCount1] = React.useState(0);
    const [count2, setCount2] = React.useState(0);
    return(
        <div style={{margin:"30px"}}>
            <div>
                <p>Счетчик 1</p>
                <button onClick={()=>setCount1(count1+1)}>+</button>
                <div><Count id={1} value={count1}/></div>
            </div>
            <div>
                <p>Счетчик 2</p>
                <button onClick={()=>setCount2(count2+1)}>+</button>
                <div style={{display: 'inline-block'}}>
                    <Count id={2} value={count2}/>
                    <IsFive value={count2}/>
                </div>
            </div>
        </div>
    )
}

export default App;
